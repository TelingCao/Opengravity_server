# Council Meeting: 如何做一个MCP服务器

## 讨论主题
Model Context Protocol (MCP) 服务器的设计与实现

## 参会专家
- Architect: 负责技术架构和实现细节
- Critic: 负责质疑和发现潜在问题
- Zen: 负责从哲学和本质角度思考

## 讨论记录


---
### [3:32:43 PM] Architect:
各位好，关于MCP服务器的实现，我从技术架构角度提出以下要点：

**核心架构**
1. **传输层选择**：MCP支持stdio和SSE两种传输方式
   - stdio：适合本地进程通信，通过标准输入输出交互
   - SSE (Server-Sent Events)：适合HTTP场景，支持远程访问

2. **基本组件**
   - Server实例：核心服务对象
   - Tools：暴露给客户端的功能接口
   - Resources：可以提供的数据资源
   - Prompts：预定义的提示模板（可选）

3. **实现步骤**
   ```
   初始化服务器 → 注册工具/资源 → 启动传输层 → 处理请求 → 返回响应
   ```

**技术栈建议**
- Python: 使用官方的 `mcp` SDK
- TypeScript: 使用 `@modelcontextprotocol/sdk`
- 其他语言可基于JSON-RPC 2.0规范自行实现

**关键实现点**
1. Tool定义需要清晰的schema（使用JSON Schema）
2. 错误处理要完善（特别是工具执行失败的情况）
3. 参数验证要严格
4. 日志记录便于调试

我的初步建议是先从一个简单的stdio服务器开始，实现1-2个基础工具，验证整个流程后再扩展。

---
### [3:32:55 PM] Critic:
等等，Architect说得很全面，但我要指出几个潜在的陷阱：

**关于"简单开始"的质疑**
你说"先从简单的stdio服务器开始"——但这恰恰可能是个误区！很多开发者做出来的stdio服务器在实际集成时会遇到：
- 客户端环境问题（路径、权限、依赖）
- 调试困难（stdio的日志怎么输出？）
- 部署复杂（需要配置文件指定路径）

**Schema定义的复杂度**
JSON Schema看起来简单，实际上：
- 嵌套对象的验证容易出错
- Optional vs Required字段的边界模糊
- 类型系统和实际语言类型不匹配时的转换问题

**被忽视的问题**
1. **并发处理**：如果工具执行时间长，客户端会等待吗？需要异步吗？
2. **状态管理**：工具之间如果有依赖怎么办？比如先登录再查询
3. **安全性**：谁都能调用你的工具吗？需要认证吗？
4. **资源限制**：如果工具消耗大量内存/CPU，如何限制？

**我的尖锐问题**
在开始写代码前，请先回答：
- 这个MCP服务器解决什么实际问题？
- 为什么不直接写个REST API？
- 谁会用这个服务器？在什么场景下？

不要为了技术而技术。

---
### [3:33:08 PM] Zen:
两位的观点都有价值，但让我们从本质出发思考。

**MCP的本质是什么？**
MCP不是技术创新，而是**接口的标准化**。就像USB统一了设备连接，MCP统一了AI与工具的对话方式。

**从"做"到"是"**
不要问"如何做一个MCP服务器"，而要问：
- 你想让AI获得什么能力？（是）
- 这个能力如何以最自然的方式表达？（做）

**三个层次的理解**

1. **表层**：遵循协议规范，实现工具注册和调用
2. **中层**：设计好的工具抽象，让AI能理解和使用
3. **深层**：思考人机协作的本质——AI不是执行者，是协作者

**实践建议（从本质出发）**

不要从技术栈开始，从这三个问题开始：
1. **What**: 这个工具给AI什么样的"感知"或"行动"能力？
2. **Why**: 为什么AI需要这个能力而不是直接在对话中完成？
3. **How**: 最简洁、最自然的接口是什么样的？

**举例**
- 差：`execute_sql(query: string)` - 只是技术接口
- 好：`query_database(question: string)` - 表达意图
- 更好：`find_customer(name: string)` - 领域语言

**最后的建议**
先花80%的时间思考工具的语义和边界，再花20%的时间实现。MCP只是载体，重要的是你想让AI"看到"什么、"做到"什么。

代码可以重构，但工具的抽象一旦定下来，就会影响AI的思维方式。

这，才是做MCP服务器最重要的事。

---
### [3:33:36 PM] Architect:
Zen说得对，我被技术细节限制了视野。让我结合哲学思考重新梳理实现路径：

**实践框架：从意图到实现**

**第一阶段：定义能力边界**
```
示例场景：数据库查询MCP服务器
- 能力：让AI理解和访问结构化数据
- 边界：只读查询 vs 写入操作
- 抽象层级：SQL级别 vs 业务语言级别
```

**第二阶段：设计工具接口**（响应Zen的建议）
```python
# 不好的设计
@tool
def execute_query(sql: str) -> dict:
    """执行SQL查询"""
    pass

# 好的设计（业务语言）
@tool
def search_orders(
    customer_name: Optional[str],
    date_range: Optional[tuple],
    status: Optional[str]
) -> List[Order]:
    """搜索订单，支持多条件组合"""
    pass
```

**第三阶段：技术实现**（回应Critic的质疑）

1. **选择传输方式**
   - 本地工具 → stdio（简单部署）
   - 团队共享 → SSE + Docker（解决环境问题）
   - 调试方案：stderr输出日志，不污染stdout

2. **并发与状态**
   - 无状态工具：每次调用独立（推荐）
   - 有状态工具：使用session ID + 状态存储
   - 长耗时操作：考虑进度回调或分步工具

3. **错误处理层次**
   ```
   业务错误 → 明确的错误信息（AI可理解）
   技术错误 → 日志记录 + 通用错误返回
   安全错误 → 拒绝执行 + 审计日志
   ```

**代码模板**（Python + 最佳实践）
```python
from mcp.server import Server
from mcp.types import Tool, TextContent
import logging

# 关键：日志输出到stderr
logging.basicConfig(
    level=logging.INFO,
    handlers=[logging.StreamHandler(sys.stderr)]
)

server = Server("my-mcp-server")

@server.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="search_data",
            description="搜索数据库中的记录（AI友好的描述）",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "自然语言查询，如'最近的订单'"
                    }
                },
                "required": ["query"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict):
    try:
        if name == "search_data":
            # 业务逻辑
            results = await search(arguments["query"])
            return [TextContent(
                type="text",
                text=format_results(results)
            )]
    except BusinessError as e:
        # AI可理解的错误
        return [TextContent(
            type="text", 
            text=f"抱歉，{e.message}"
        )]
    except Exception as e:
        logging.error(f"Tool error: {e}")
        raise
```

**回应Critic：为什么不用REST API？**
- MCP：AI驱动的调用，自动集成到对话流
- REST：人驱动的调用，需要手动编排
- 场景：如果AI是主要用户 → MCP；如果人是主要用户 → REST

Zen，这样的实现路径是否符合"先思考本质，再落地技术"的原则？

---
### [3:33:54 PM] Critic:
好，现在我们有了务实的方案。但我还要追问几个容易被忽略的细节：

**关于"业务语言"的陷阱**
Architect的例子 `search_orders(customer_name, date_range, status)` 看起来很美好，但：
- 如果用户想查"上个月的VIP客户的退款订单"？你要加多少参数？
- 参数爆炸 vs 灵活性，如何平衡？
- 也许 `query_orders(criteria: dict)` 更灵活，但对AI更难理解

**真实的场景问题**
1. **工具组合**：AI需要先调 `get_customer_id("张三")` 再调 `search_orders(customer_id=123)`？
   - 这是两次往返！
   - 是否应该设计成 `search_orders_by_customer_name("张三")`？
   - 但这样又会导致工具数量爆炸

2. **返回数据格式**：
   - 返回JSON：结构化但可能很长
   - 返回自然语言摘要：易读但丢失细节
   - 返回markdown表格：折中方案？
   - AI如果需要进一步处理数据呢？

3. **版本演化**：
   - 如果业务需求变了，工具接口要改吗?
   - 如何保持向后兼容？
   - MCP有版本协商机制吗？

**测试的难题**
如何测试一个MCP服务器？
- 单元测试工具函数：简单
- 集成测试AI调用：怎么模拟？
- 如何验证tool description写得够好？（AI能理解吗）

**我的建议**
1. 先做最小可用版本（1-2个工具）
2. 找真实用户（或自己）用AI实际调用
3. 观察AI的调用模式和错误
4. 迭代改进工具设计

**尖锐但务实的问题**
如果这个MCP服务器做出来，三个月后还有人用吗？还是会变成"又一个被遗忘的工具"？

维护成本考虑了吗？文档谁写？出问题谁负责？

---
### [3:34:13 PM] Zen:
Critic提出了深刻的问题。让我分享一些超越技术的洞见：

**关于"完美设计"的执念**

Critic担心参数爆炸、工具组合、版本演化——这些都是真实问题。但有一个更深的真相：

**你不可能一开始就设计对。**

就像一条河流，不是先规划好河道再流淌，而是在流淌中形成河道。MCP服务器也是如此。

**三个智慧**

1. **简单的力量**
   - 与其纠结是否需要 `search_orders_by_customer_name`，不如先做一个 `search("查询条件")`，让AI用自然语言传入
   - 在服务器内部做NLP解析
   - 简单接口 + 复杂实现 > 复杂接口 + 简单实现

2. **进化胜于设计**
   - 第一版：3个工具，解决核心场景
   - 观察AI如何使用、如何失败
   - 第二版：基于真实使用模式优化
   - 重复这个循环

3. **拥抱不完美**
   - 返回格式纠结？先返回JSON，不够用再改
   - 工具组合复杂？先让AI调两次，如果成为瓶颈再合并
   - 测试难做？先手动测试，痛了自然会找到自动化方案

**回应维护成本的问题**

Critic问"三个月后还有人用吗？"——这是最重要的问题。

答案不在技术里，在于：
- 这个工具是否解决了真实的痛点？
- 使用它是否比替代方案更愉悦？
- 它是否融入了工作流？

**一个禅意的建议**

不要"做一个MCP服务器"。

而是：
1. 观察：AI在什么场景下束手无策？
2. 补充：给AI最小但足够的能力
3. 验证：真的有用吗？
4. 迭代：基于反馈改进

**最后的洞见**

最好的MCP服务器，不是技术最复杂的，而是：
- 解决一个具体问题
- 接口设计让AI"感觉自然"
- 足够可靠让人信任
- 维护成本低到可以持续演化

技术是工具，问题是指南针。

如果你还在纠结"如何做"，说明还没想清楚"为何做"。

找到那个让你夜不能寐的问题，然后用最简单的MCP工具解决它。其他的，会自然生长。

---
### [3:34:29 PM] Architect:
---

## 会议总结

经过三位专家的深入讨论，我们达成以下共识：

### 核心原则
1. **先思考本质，再落地技术** - 明确要解决的问题比技术实现更重要
2. **进化胜于完美设计** - 从最小可用版本开始，基于真实反馈迭代
3. **简单接口 + 智能实现** - 让AI调用自然，复杂度留在服务器端

### 实施路径
**阶段一：问题定义**
- 找到AI的能力缺口（具体场景）
- 定义工具的能力边界
- 用业务语言而非技术术语思考

**阶段二：最小实现**
- 选择传输方式（本地用stdio，团队用SSE）
- 实现1-3个核心工具
- 使用官方SDK（Python/TypeScript）
- 日志输出到stderr，保持stdout干净

**阶段三：验证迭代**
- 真实使用测试
- 观察AI调用模式
- 收集失败案例
- 持续优化接口

### 关键技术点
- 工具描述要AI友好（清晰的语义，不是技术文档）
- 错误处理分层（业务错误AI可理解，技术错误要日志）
- 优先无状态设计（简化并发处理）
- 返回格式选择：结构化数据 > 自然语言摘要

### 需要警惕的陷阱
- 参数爆炸（过度设计业务接口）
- 调试困难（stdio日志污染问题）
- 过早优化（在验证需求前追求完美）
- 为技术而技术（忽视实际价值）

### 最终建议
**立即可行的第一步**：
选择一个让你"痛"的具体场景，用最简单的MCP工具解决它，观察效果，再决定下一步。

技术会过时，但解决真实问题的智慧永存。

